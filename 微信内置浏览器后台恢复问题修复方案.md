# 微信内置浏览器后台恢复问题修复方案

## 📋 问题描述

在微信内置浏览器中打开 H5 页面，当用户切换到微信聊天再返回时，页面会出现以下问题：
1. **定时器被暂停** - 使用 `setInterval` 的定时更新停止
2. **WebSocket 可能断开** - 连接状态不确定
3. **数据不更新** - 页面显示的数据停留在切走前的状态

## ✅ 解决方案概述

本方案通过以下三个层次来解决问题：

### 1. 全局层 - 可见性管理器
- 监听页面可见性变化（`visibilitychange` 事件）
- 监听微信特有的页面恢复事件（`pageshow`）
- 提供统一的回调机制

### 2. WebSocket 层 - 自动重连增强
- 页面恢复时智能检测连接状态
- 延迟重连避免 fd 冲突
- 支持从缓存恢复的处理

### 3. 页面层 - 定时器和数据刷新
- onShow 时重启定时器
- onHide 时清理定时器
- 监听全局恢复事件

## 🚀 已完成的修改

### 1. 新增文件

#### `/common/visibilityManager.js`
页面可见性管理器，提供统一的可见性监听和回调机制。

**特性：**
- ✅ 监听 `visibilitychange` 事件
- ✅ 监听 `pageshow` 事件（处理 bfcache）
- ✅ 监听 `focus/blur` 事件
- ✅ 支持微信 JS-SDK
- ✅ 提供优先级回调机制
- ✅ 记录页面隐藏时长

### 2. 修改文件

#### `main.js`
- ✅ 初始化 `uni.$visibilityManager`
- ✅ 关联 WebSocket 与可见性管理器
- ✅ 页面恢复时自动检查 WebSocket 连接

#### `App.vue`
- ✅ 增强 `onShow/onHide` 处理
- ✅ 记录后台时长
- ✅ 后台时间超过 5 秒时执行深度恢复
- ✅ 触发全局恢复事件 `app_resumed_from_background`

#### `common/websocketUtils.js`
- ✅ 增强页面可见性监听
- ✅ 记录页面隐藏时长
- ✅ 支持 `pageshow` 事件（bfcache 恢复）
- ✅ 新增 `setPageVisibilityCallbacks` 方法

## 📖 使用方法

### 方法一：使用可见性管理器（推荐）

在需要处理页面恢复的页面中添加监听：

```javascript
export default {
  data() {
    return {
      visibilityUnsubscribe: null,  // 取消监听的函数
      balancetimer: null,
      periodtimer: null
    };
  },
  
  onLoad() {
    // 添加页面可见性监听
    this.visibilityUnsubscribe = uni.$visibilityManager.addListener('visible', (data) => {
      console.log('📱 页面恢复可见', data);
      
      // 1. 立即刷新一次数据
      this.refreshData();
      
      // 2. 如果定时器不存在，重启定时器
      if (!this.balancetimer) {
        this.startBalanceTimer();
      }
      if (!this.periodtimer) {
        this.startPeriodTimer();
      }
      
      // 3. 如果隐藏时间较长（超过10秒），执行深度刷新
      if (data.hiddenDuration > 10000) {
        console.log('⚡ 后台时间较长，执行深度刷新');
        this.deepRefresh();
      }
    }, { priority: 50 });  // 可设置优先级
  },
  
  onUnload() {
    // 页面卸载时取消监听
    if (this.visibilityUnsubscribe) {
      this.visibilityUnsubscribe();
    }
    
    // 清理定时器
    this.clearAllTimers();
  },
  
  methods: {
    // 启动定时器
    startBalanceTimer() {
      if (this.balancetimer) {
        clearInterval(this.balancetimer);
      }
      this.balancetimer = setInterval(() => {
        if (uni.$socketUtils.isOpenSocket) {
          uni.$socketUtils.send({eventType: "getBalanceInfo"});
        }
      }, 8000);
    },
    
    startPeriodTimer() {
      if (this.periodtimer) {
        clearInterval(this.periodtimer);
      }
      this.periodtimer = setInterval(() => {
        this.timerCheck();
      }, 1000);
    },
    
    // 刷新数据
    refreshData() {
      if (uni.$socketUtils.isOpenSocket) {
        uni.$socketUtils.send({eventType: "getBalanceInfo"});
        uni.$socketUtils.send({eventType: "periodListOrSingle"});
      }
      this.getRoomConfig();
    },
    
    // 深度刷新
    deepRefresh() {
      this.refreshData();
      // 其他需要深度刷新的操作
    },
    
    // 清理所有定时器
    clearAllTimers() {
      if (this.balancetimer) {
        clearInterval(this.balancetimer);
        this.balancetimer = null;
      }
      if (this.periodtimer) {
        clearInterval(this.periodtimer);
        this.periodtimer = null;
      }
    }
  }
};
```

### 方法二：使用 onShow/onHide（现有代码改进）

如果页面已经有 `onShow/onHide`，只需改进即可：

```javascript
export default {
  data() {
    return {
      balancetimer: null,
      periodtimer: null,
      isPageActive: false  // 页面是否活跃
    };
  },
  
  onShow() {
    console.log('📱 页面 onShow');
    this.isPageActive = true;
    
    // 重启定时器
    this.startAllTimers();
    
    // 立即刷新一次数据
    this.refreshData();
    
    // 🆕 监听全局恢复事件（App.vue 触发）
    uni.$on('app_resumed_from_background', this.handleAppResume);
  },
  
  onHide() {
    console.log('📱 页面 onHide');
    this.isPageActive = false;
    
    // 清理定时器
    this.clearAllTimers();
    
    // 🆕 取消监听
    uni.$off('app_resumed_from_background', this.handleAppResume);
  },
  
  methods: {
    // 处理应用恢复
    handleAppResume(data) {
      console.log('⚡ 应用从后台恢复', data);
      
      // 如果当前页面是活跃的，刷新数据
      if (this.isPageActive) {
        this.refreshData();
        
        // 如果定时器不存在，重启
        if (!this.balancetimer || !this.periodtimer) {
          this.startAllTimers();
        }
      }
    },
    
    startAllTimers() {
      // 清理旧定时器
      this.clearAllTimers();
      
      // 启动新定时器
      this.periodtimer = setInterval(() => {
        if (this.isPageActive) {
          this.timerCheck();
        }
      }, 1000);
      
      this.balancetimer = setInterval(() => {
        if (this.isPageActive && uni.$socketUtils.isOpenSocket) {
          uni.$socketUtils.send({eventType: "getBalanceInfo"});
          uni.$socketUtils.send({eventType: "periodListOrSingle"});
        }
      }, 8000);
    },
    
    clearAllTimers() {
      if (this.periodtimer) {
        clearInterval(this.periodtimer);
        this.periodtimer = null;
      }
      if (this.balancetimer) {
        clearInterval(this.balancetimer);
        this.balancetimer = null;
      }
    },
    
    refreshData() {
      if (uni.$socketUtils.isOpenSocket) {
        uni.$socketUtils.send({eventType: "getBalanceInfo"});
        uni.$socketUtils.send({eventType: "periodListOrSingle"});
      }
    }
  }
};
```

### 方法三：结合使用（最佳实践）

```javascript
export default {
  data() {
    return {
      visibilityUnsubscribe: null,
      balancetimer: null,
      periodtimer: null,
      isPageActive: false,
      pageHideTime: null
    };
  },
  
  onLoad() {
    // 🆕 添加可见性监听（H5 专用）
    // #ifdef H5
    this.visibilityUnsubscribe = uni.$visibilityManager.addListener('both', (data) => {
      if (uni.$visibilityManager.isVisible()) {
        console.log('🟢 页面可见', data);
        this.handlePageVisible(data);
      } else {
        console.log('🔴 页面隐藏', data);
        this.handlePageHidden();
      }
    });
    // #endif
  },
  
  onShow() {
    console.log('📱 onShow');
    this.isPageActive = true;
    
    const hiddenDuration = this.pageHideTime ? Date.now() - this.pageHideTime : 0;
    this.handlePageVisible({ hiddenDuration, source: 'onShow' });
    
    // 监听全局事件
    uni.$on('app_resumed_from_background', this.handleAppResume);
  },
  
  onHide() {
    console.log('📱 onHide');
    this.isPageActive = false;
    this.pageHideTime = Date.now();
    
    this.handlePageHidden();
    
    uni.$off('app_resumed_from_background', this.handleAppResume);
  },
  
  onUnload() {
    // 清理
    if (this.visibilityUnsubscribe) {
      this.visibilityUnsubscribe();
    }
    this.clearAllTimers();
    uni.$off('app_resumed_from_background', this.handleAppResume);
  },
  
  methods: {
    // 页面变为可见
    handlePageVisible(data) {
      console.log('✅ 处理页面可见', data);
      
      // 1. 重启定时器
      if (!this.balancetimer || !this.periodtimer) {
        this.startAllTimers();
      }
      
      // 2. 立即刷新数据
      this.refreshData();
      
      // 3. 如果隐藏时间较长，深度刷新
      if (data.hiddenDuration && data.hiddenDuration > 10000) {
        console.log('⚡ 执行深度刷新');
        this.deepRefresh();
      }
    },
    
    // 页面变为隐藏
    handlePageHidden() {
      console.log('⏸️ 处理页面隐藏');
      
      // 清理定时器（可选，某些场景可能希望保持运行）
      // this.clearAllTimers();
    },
    
    // 应用恢复
    handleAppResume(data) {
      if (this.isPageActive) {
        this.handlePageVisible(data);
      }
    },
    
    startAllTimers() {
      this.clearAllTimers();
      
      this.periodtimer = setInterval(() => {
        if (this.isPageActive) {
          this.timerCheck();
        }
      }, 1000);
      
      this.balancetimer = setInterval(() => {
        if (this.isPageActive && uni.$socketUtils.isOpenSocket) {
          this.sendWebSocketMessages();
        }
      }, 8000);
      
      console.log('✅ 所有定时器已启动');
    },
    
    clearAllTimers() {
      if (this.periodtimer) {
        clearInterval(this.periodtimer);
        this.periodtimer = null;
      }
      if (this.balancetimer) {
        clearInterval(this.balancetimer);
        this.balancetimer = null;
      }
    },
    
    refreshData() {
      if (uni.$socketUtils.isOpenSocket) {
        this.sendWebSocketMessages();
      }
      this.getRoomConfig();
    },
    
    sendWebSocketMessages() {
      uni.$socketUtils.send({eventType: "getBalanceInfo"});
      uni.$socketUtils.send({eventType: "periodListOrSingle"});
      uni.$socketUtils.send({eventType: "openResult", gid: this.gid});
    },
    
    deepRefresh() {
      this.refreshData();
      // 可以添加其他深度刷新操作
      // 例如：重新加载聊天记录、重新获取配置等
      this.loadChatRecords();
    }
  }
};
```

## 🎯 针对现有聊天页面的修复

对于 `copage/chat.vue` 和 `copage/chatnew.vue`，建议采用以下修复方案：

### 修复步骤：

1. **在 data 中添加状态标记**
```javascript
data() {
  return {
    // ... 现有的 data
    visibilityUnsubscribe: null,
    isPageActive: false,
    pageHideTime: null
  }
}
```

2. **在 onLoad 中添加可见性监听**
```javascript
onLoad() {
  // ... 现有的 onLoad 代码
  
  // #ifdef H5
  this.visibilityUnsubscribe = uni.$visibilityManager.addListener('visible', (data) => {
    console.log('📱 聊天页面恢复可见', data);
    if (this.isPageActive) {
      this.handlePageResume(data);
    }
  });
  // #endif
}
```

3. **改进 onShow**
```javascript
onShow() {
  if (this.previewImageFlag) {
    this.previewImageFlag = false;
    return;
  }
  
  this.isPageActive = true;
  const hiddenDuration = this.pageHideTime ? Date.now() - this.pageHideTime : 0;
  console.log(`📱 聊天页面 onShow，隐藏时长: ${(hiddenDuration/1000).toFixed(1)}秒`);
  
  // 启动所有定时器
  this.startAllTimers();
  
  // 立即刷新数据
  this.refreshChatData();
  
  // 监听全局事件
  uni.$on('app_resumed_from_background', this.handleAppResume);
}
```

4. **改进 onHide**
```javascript
onHide() {
  this.isPageActive = false;
  this.pageHideTime = Date.now();
  console.log('📱 聊天页面 onHide');
  
  // 清理定时器
  this.clearAllTimers();
  
  // 取消监听
  uni.$off('app_resumed_from_background', this.handleAppResume);
}
```

5. **添加辅助方法**
```javascript
methods: {
  // ... 现有的 methods
  
  // 处理页面恢复
  handlePageResume(data) {
    console.log('⚡ 聊天页面恢复处理', data);
    
    // 1. 检查并重启定时器
    if (!this.periodtimer || !this.balancetimer) {
      this.startAllTimers();
    }
    
    // 2. 刷新数据
    this.refreshChatData();
    
    // 3. 如果隐藏时间较长，执行深度刷新
    if (data.hiddenDuration > 10000) {
      this.deepRefreshChatData();
    }
  },
  
  // 应用恢复处理
  handleAppResume(data) {
    if (this.isPageActive) {
      this.handlePageResume(data);
    }
  },
  
  // 启动所有定时器
  startAllTimers() {
    console.log('🕐 启动所有定时器');
    
    // 清理旧定时器
    this.clearAllTimers();
    
    // 启动期号定时器
    if (!this.periodtimer) {
      this.getperiod();
      this.periodtimer = setInterval(() => {
        if (!this.isDestroyed && this.isPageActive) {
          this.timerCheck();
          this.gitemTimeCheck();
        }
      }, 1000);
    }
    
    // 启动余额定时器
    if (!this.balancetimer) {
      const queryInterval = this.utype === 1 ? 10000 : 8000;
      this.balancetimer = setInterval(() => {
        if (!this.isDestroyed && this.isPageActive && uni.$socketUtils.isOpenSocket) {
          this.sendWebSocketQueries();
          this.getRoomConfig();
        }
      }, queryInterval);
    }
  },
  
  // 清理所有定时器
  clearAllTimers() {
    if (this.periodtimer) {
      clearInterval(this.periodtimer);
      this.periodtimer = null;
    }
    if (this.balancetimer) {
      clearInterval(this.balancetimer);
      this.balancetimer = null;
    }
  },
  
  // 发送 WebSocket 查询
  sendWebSocketQueries() {
    if (this.utype === 1) {
      // 房主账号分散发送
      uni.$socketUtils.send({eventType:"openResult", gid:this.gid});
      setTimeout(() => {
        uni.$socketUtils.send({eventType:"periodListOrSingle"});
      }, 200);
      setTimeout(() => {
        uni.$socketUtils.send({eventType:"getBalanceInfo"});
      }, 400);
    } else {
      // 普通会员
      uni.$socketUtils.send({eventType:"getBalanceInfo"});
      uni.$socketUtils.send({eventType:"periodListOrSingle"});
      uni.$socketUtils.send({eventType:"openResult", gid:this.gid});
    }
  },
  
  // 刷新聊天数据
  refreshChatData() {
    console.log('🔄 刷新聊天数据');
    this.sendWebSocketQueries();
    this.getRoomConfig();
    this.getperiod();
  },
  
  // 深度刷新聊天数据
  deepRefreshChatData() {
    console.log('⚡ 深度刷新聊天数据');
    this.refreshChatData();
    // 重新加载聊天记录
    // this.loadChatRecords();  // 如果有此方法
    // 其他需要深度刷新的操作
  }
}
```

6. **在 onUnload 中清理**
```javascript
onUnload() {
  // 清理可见性监听
  if (this.visibilityUnsubscribe) {
    this.visibilityUnsubscribe();
  }
  
  // 清理定时器
  this.clearAllTimers();
  
  // 取消全局事件监听
  uni.$off('app_resumed_from_background', this.handleAppResume);
  
  // ... 其他现有的清理代码
}
```

## 🧪 测试步骤

### 1. 微信内置浏览器测试

1. 在微信中打开 H5 页面
2. 等待数据正常更新（观察倒计时、余额等）
3. 切换到微信聊天（发送几条消息）
4. 等待 10-30 秒
5. 切换回 H5 页面
6. **预期结果：**
   - 页面立即恢复更新
   - 倒计时继续运行
   - 数据刷新到最新状态
   - WebSocket 自动重连（如果断开）
   - 控制台显示恢复日志

### 2. 长时间后台测试

1. 在微信中打开 H5 页面
2. 切换到微信聊天
3. 等待 1-2 分钟
4. 切换回 H5 页面
5. **预期结果：**
   - 触发深度刷新
   - 所有数据更新到最新
   - 定时器正常运行

### 3. 多次切换测试

1. 在微信中打开 H5 页面
2. 快速切换微信聊天和 H5 页面 5-10 次
3. **预期结果：**
   - 每次切换都能正常恢复
   - 没有重复的定时器
   - WebSocket 连接稳定

## 📊 验证指标

运行以下代码检查是否正常工作：

```javascript
// 在浏览器控制台运行
console.log('=== 页面可见性管理器状态 ===');
console.log('是否可见:', uni.$visibilityManager.isVisible());
console.log('隐藏时长:', uni.$visibilityManager.getHiddenDuration(), 'ms');
console.log('监听器数量:', uni.$visibilityManager.listeners.length);

console.log('\n=== WebSocket 状态 ===');
console.log('是否连接:', uni.$socketUtils.isOpenSocket);
console.log('是否正在重连:', uni.$socketUtils.isReconnecting);
console.log('重连次数:', uni.$socketUtils.reconnectAttempts);

// 手动触发页面恢复
uni.$visibilityManager.manualRefresh();
```

## 🐛 常见问题

### Q1: 页面恢复后数据还是不更新？
**A:** 检查：
1. 定时器是否正常重启（查看控制台日志）
2. WebSocket 是否重连成功
3. onShow 中是否调用了 `refreshData()`
4. 是否在 onHide 中错误地阻止了某些操作

### Q2: 定时器重复运行？
**A:** 确保：
1. 在 `startAllTimers()` 开始时调用 `clearAllTimers()`
2. onShow 中不要多次调用 `startAllTimers()`
3. 可见性监听器中检查定时器是否已存在

### Q3: H5 和小程序表现不一致？
**A:** 
- H5 使用 `visibilitychange` 事件
- 小程序/APP 使用 `onShow/onHide`
- 使用条件编译 `#ifdef H5` 来区分处理

### Q4: 微信环境检测不准确？
**A:** 使用以下代码检测：
```javascript
const ua = window.navigator.userAgent.toLowerCase();
const isWechat = ua.indexOf('micromessenger') !== -1;
console.log('是否微信环境:', isWechat);
```

## 📝 注意事项

1. **定时器管理**
   - 始终在启动新定时器前清理旧定时器
   - 在定时器回调中检查页面是否活跃

2. **WebSocket 管理**
   - 页面隐藏时保持连接，不要主动断开
   - 页面恢复时让自动重连机制处理

3. **性能优化**
   - 避免在页面恢复时执行过多耗时操作
   - 考虑使用防抖/节流机制

4. **兼容性**
   - 方案支持 H5、微信小程序、APP
   - 使用条件编译处理平台差异

## 🎉 预期效果

修复后，用户在微信中使用的体验将显著改善：

✅ 切换回页面后，数据立即开始更新  
✅ 倒计时继续运行，不会卡住  
✅ WebSocket 自动重连，消息实时推送  
✅ 长时间后台后恢复，数据完全同步  
✅ 多次快速切换，依然稳定运行  

---

**文档版本**: 1.0  
**更新日期**: 2025-11-04  
**适用项目**: chsgappV2 (uni-app)

